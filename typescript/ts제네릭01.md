ğŸ¯ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­(Generic)
ì œë„¤ë¦­ì´ë€ íƒ€ì…ì„ ë§ˆì¹˜ í•¨ìˆ˜ì˜ íŒŒë¼ë¯¸í„°ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
ì •ì  type ì–¸ì–´ëŠ” í´ë˜ìŠ¤ë‚˜ í•¨ìˆ˜ë¥¼ ì •ì˜í•  ë•Œ typeì„ ì„ ì–¸í•´ì•¼ í•œë‹¤.
Genericì€ ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œê°€ ì•„ë‹ˆë¼ ì½”ë“œë¥¼ ìˆ˜í–‰ë  ë•Œ(ëŸ°íƒ€ì„) íƒ€ì…ì„ ëª…ì‹œí•œë‹¤.
ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ ì‹ë³„ìë¥¼ ì¨ì„œ ì•„ì§ ì •í•´ì§€ì§€ ì•Šì€ íƒ€ì…ì„ í‘œì‹œí•œë‹¤.
ì¼ë°˜ì ìœ¼ë¡œ ì‹ë³„ìëŠ” T, U, V ...ë¥¼ ì‚¬ìš©í•œë‹¤.
í•„ë“œ ì´ë¦„ì˜ ì²« ê¸€ìë¥¼ ì‚¬ìš©í•˜ê¸°ë„ í•œë‹¤.


ğŸ“ generic ì‚¬ìš© ì´ìœ 
í•œ ê°€ì§€ íƒ€ì…ë³´ë‹¤ ì—¬ëŸ¬ ê°€ì§€ íƒ€ì…ì—ì„œ ë™ì‘í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.
ì¬ì‚¬ìš©ì„±ì´ ë†’ì€ í•¨ìˆ˜ì™€ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤.
ì—¬ëŸ¬ íƒ€ì…ì—ì„œ ë™ì‘ì´ ê°€ëŠ¥í•˜ë‹¤. (í•œ ë²ˆì˜ ì„ ì–¸ìœ¼ë¡œ ë‹¤ì–‘í•œ íƒ€ì…ì— ì¬ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.)
ì½”ë“œì˜ ê°€ë…ì„±ì´ í–¥ìƒëœë‹¤.
ì˜¤ë¥˜ë¥¼ ì‰½ê²Œ í¬ì°©í•  ìˆ˜ ìˆë‹¤.
anyíƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ì»´íŒŒì¼ ì‹œ íƒ€ì…ì„ ì²´í¬í•˜ì§€ ì•ŠëŠ”ë‹¤.
íƒ€ì…ì„ ì²´í¬í•˜ì§€ ì•Šì•„ ê´€ë ¨ ë©”ì„œë“œì˜ íŒíŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
ì»´íŒŒì¼ ì‹œì— ì»´íŒŒì¼ëŸ¬ê°€ ì˜¤ë¥˜ë¥¼ ì°¾ì§€ ëª»í•œë‹¤.
genericë„ anyì²˜ëŸ¼ íƒ€ì…ì„ ì§€ì •í•˜ì§€ ì•Šì§€ë§Œ, íƒ€ì…ì„ ì²´í¬í•´ ì»´íŒŒì¼ëŸ¬ê°€ ì˜¤ë¥˜ë¥¼ ì°¾ì„ ìˆ˜ ìˆë‹¤.


ğŸ“ genericì„ í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•˜ê¸°
function sort<T>(item: T[]): T[] {
return item.sort();
}

const nums: number[] = [1, 2, 3, 4];
const chars: string[] = ["a", "b", "c", "d", "e", "f", "g",];

sort<number>(nums);
sort<string>(chars);
function logText<T>(text: T): T {
return text;
}
// 1ê³¼ 2ëŠ” ê°™ì€ ì˜ë¯¸
// #1
let str: <T>(text: T) => T = logText;
// #2
let str: {<T>(text: T): T} = logText;
í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ í•¨ìˆ˜ ì•ˆì—ì„œ ì‚¬ìš©í•  íƒ€ì…ì„ ë„˜ê²¨ì¤„ ìˆ˜ ìˆë‹¤.


ğŸ“• ì œë„¤ë¦­ ì¸í„°í˜ì´ìŠ¤
interface GenericLogTextFn {
<T>(text: T): T;
}
function logText<T>(text: T): T {
return text;
}
let myString: GenericLogTextFn = logText; // Okay

// ì¸í„°í˜ì´ìŠ¤ì— ì¸ì íƒ€ì…ì„ ê°•ì¡°
interface GenericLogTextFn<T> {
(text: T): T;
}
function logText<T>(text: T): T {
return text;
}
let myString: GenericLogTextFn<string> = logText;


ğŸ“ genericì„ classì—ì„œ ì‚¬ìš©í•˜ê¸°
class Queue<T> {
protected data: Array<T> = [];

    push(item: T) {
        this.data.push(item);
    }
 
    pop(): T | undefined {
        return this.data.shift();
    }
}

const numberQueue = new Queue<number>();

numberQueue.push(0);
numberQueue.push("1"); // ì˜ë„í•˜ì§€ ì•Šì€ ì‹¤ìˆ˜ë¥¼ ì‚¬ì „ ê²€ì¶œ ê°€ëŠ¥
numberQueue.push(+"1"); // ì‹¤ìˆ˜ë¥¼ ì‚¬ì „ ì¸ì§€í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.


ğŸ“ Union type
// anyë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°
function getAge(age: any) {
age.toFixe(); // ì—ëŸ¬ ë°œìƒ, ageì˜ íƒ€ì…ì´ anyë¡œ ì¶”ë¡ ë˜ê¸° ë•Œë¬¸ì— ìˆ«ì ê´€ë ¨ëœ APIë¥¼ ì‘ì„±í•  ë•Œ ì½”ë“œê°€ ìë™ ì™„ì„±ë˜ì§€ ì•ŠëŠ”ë‹¤.
return age;
}

// ìœ ë‹ˆì˜¨ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°
function getAge(age: number | string) {
if (typeof age === 'number') {
age.toFixed(); // ì •ìƒ ë™ì‘, ageì˜ íƒ€ì…ì´ `number`ë¡œ ì¶”ë¡ ë˜ê¸° ë•Œë¬¸ì— ìˆ«ì ê´€ë ¨ëœ APIë¥¼ ì‰½ê²Œ ìë™ì™„ì„± í•  ìˆ˜ ìˆë‹¤.
return age;
}
if (typeof age === 'string') {
return age;
}
return new TypeError('age must be number or string');
}
|ë¥¼ ì‚¬ìš©í•´ ë‘ ê°œ ì´ìƒì˜ íƒ€ì…ì„ ì„ ì–¸í•˜ëŠ” ë°©ì‹
Unionê³¼ Generic ëª¨ë‘ ì—¬ëŸ¬ íƒ€ì…ì„ ë‹¤ë£° ìˆ˜ ìˆë‹¤.
Unionì€ ì„ ì–¸í•œ ê³µí†µëœ ë©”ì„œë“œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
ë¦¬í„´ ê°’ì´ í•˜ë‚˜ì˜ íƒ€ì…ì´ ì•„ë‹Œ ì„ ì–¸ëœ Union íƒ€ì…ìœ¼ë¡œ ì§€ì •ëœë‹¤.


ğŸ“ ì œì•½ì¡°ê±´(Constraints / keyof)
ì›í•˜ì§€ ì•ŠëŠ” ì†ì„±ì— ì ‘ê·¼í•˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´ Genericì— ì œì•½ì¡°ê±´ì„ ì‚¬ìš©í•œë‹¤.


ğŸ“• Constraints
const printMessage = <T extends string | number>(message: T):T => {
return message;
}

printMessage<string>("1");
printMessage<number>(1);
printMessage<boolean>(false); // error : Type 'boolean' does not satisfy the constraint 'string | number'.
extends í‚¤ì›Œë“œë¡œ ì œì•½ì¡°ê±´ì„ ê±¸ì–´ì¤€ë‹¤.
íŠ¹ì • íƒ€ì…ë“¤ë¡œë§Œ ë™ì‘í•˜ëŠ” generic í•¨ìˆ˜ë¥¼ ë§Œë“¤ ë•Œ ì‚¬ìš©í•œë‹¤.
Generic Tì— ì œì•½ ì¡°ê±´ì„ ì„¤ì •í•œë‹¤.(ë¬¸ìì—´ or ìˆ«ì)
ì œì•½ ì¡°ê±´ì„ ë²—ì–´ë‚˜ëŠ” íƒ€ì…ì„ ì„ ì–¸í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.


ğŸ“• keyof
const getProperty = <T extends object, U extends keyof T>(obj: T, key: U) => {
return obj[key];
}

getProperty( { a: 1, b: 2, c: 3 }, "a");
getProperty( { a: 1, b: 2, c: 3 }, "z"); // error : Argument of type '"z"' is not assignable to parameter of type '"a" | "b" | "c"'.
ë‘ ê°ì²´ë¥¼ ë¹„êµí•  ë•Œ ì‚¬ìš©í•œë‹¤.
ìœ„ ì˜ˆì œì—ì„œëŠ” ë‘ ë²ˆì§¸ í•¨ìˆ˜ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
Generic TëŠ” í‚¤ ê°’ì´ a, b, cë§Œ ì¡´ì¬í•˜ëŠ” objectì´ë‹¤.
Uì˜ ê°’ì¸ 'z'ê°€ Generic Tì˜ í‚¤ ê°’ ì¤‘ ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.


ğŸ“ Factory Pattern with Generics
interface Car {
drive(): void;
park(): void;
}

class Bus implements Car {
drive(): void {}
park(): void {}
}

class Taxi implements Car {
drive(): void {}
park(): void {}
}

class CarFactory {
static getInstance(type: String): Car {
// carì˜ typeì´ ì¶”ê°€ë  ë•Œë§ˆë‹¤, case ë¬¸ì„ ì¶”ê°€í•´ì•¼ í•˜ëŠ” ë‹¨ì 
switch (type) {
case "bus":
return new Bus();
default:
return new Taxi();
}
}
}

const bus = CarFactory.getInstance("bus");
const taxi = CarFactory.getInstance("taxi");


ğŸ›  ë””ìì¸ íŒ¨í„´ ì ìš©
interface Car {
drive(): void;
park(): void;
}

class Bus implements Car {
drive(): void {}
park(): void {}
}

class Taxi implements Car {
drive(): void {}
park(): void {}
}

class Suv implements Car {
drive(): void {}
park(): void {}
}

class CarFactory {
static getInstance<T extends Car>(type: { new (): T}): T {
return new type();
}
}

const bus = CarFactory.getInstance(bus);
const taxi = CarFactory.getInstance(taxi);
ê°ì²´ë¥¼ ìƒì„±í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë§Œ ë¯¸ë¦¬ ì •ì˜í•˜ê³ , ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ í´ë˜ìŠ¤ì˜ ê²°ì •ì€ ì„œë¸Œ í´ë˜ìŠ¤ê°€ ë‚´ë¦¬ëŠ” íŒ¨í„´
ì—¬ëŸ¬ ê°œì˜ ì„œë¸Œ í´ë˜ìŠ¤ë¥¼ ê°€ì§„ ìŠˆí¼ í´ë˜ìŠ¤ê°€ ìˆì„ ë•Œ, ì…ë ¥ì— ë”°ë¼ í•˜ë‚˜ì˜ ì„œë¸Œ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•œë‹¤.


- ì¶œì²˜ : https://lakelouise.tistory.com/188