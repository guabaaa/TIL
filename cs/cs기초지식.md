# cs 기초지식

### Web Server와 Web Application Server의 차이

- web Server는 정적인 컨텐츠를 제공해주는 소프트웨어 이고 WAS는 동적인 컨텐츠를 주로 제공해주는 소프트웨어입니다. WAS에서 동적인 컨텐츠 뿐만 아니라 정적인 컨텐츠까지 제공이 가능하지만 둘을 분리하여 사용하는 이유는 자원의 효율적인 사용과 문제 해결 및 유지 보수의 편리성 때문입니다.

### 어떻게 프로젝트 아키텍처를 설계하였나요

- 효율적인 아키텍처를 설계하기 위해서 정말 많은 고민을 하였는데요. 초기에는 서버의 과부화를 막기 위하여 AWS 로드밸런서에 여러개의 EC2 인스턴스를 등록하여 사용하려고 하였지만 비용적인 측면과 현재 저희 서비스를 사용하는 사용자 수 측면에서 오버 스팩이라고 판단하여 한개의 Ec2 서버만 사용하기로 하였고, 등록된 Ec2 인스턴스에서 2개의 spring application server를 실행시키고 nginx를 사용하여 무중단 배포가 가능하도록 하였습니다. 또한 github action을 사용하여 배포 자동화 까지 설정하였습니다.
- spring은 WAS , EC2는 리눅스 컴퓨터, nginx도 Web Server

## 전반적인 기초 cs 지식

### RESTful API

RESTful API는 HTTP 통신에서 어떤 차원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식입니다. 그 구성으로는 Resoure(url), Method(get,post,put,delete), Representation(JSON, XML)이 있습니다.

## 객체지향 프로그래밍이란(OOP)

객체지향 프로그래밍은 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 기법입니다.

### 객체란?

자신의 속성을 가지고 있고 다른것과 식별이 가능한 것.

### 객체지향 프로그래밍의 특징

- 캡슐화
- 상속
- 다형성

### 객체 지향 프로그래밍의 장,단점 ??

장점

- 코드 재사용성이 용이하다.
    - 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음
- 유지보수가 쉬움
    - 절차 지향 프로그래밍에서는 코드를 수정해야 할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면된다.
- 대형 프로젝트에 적합
    - 클래스 단위로 모듈화시켜서 개발 할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.

단점

- 처리속도가 상대적으로 느리다.
- 객체가 많으면 용량이 커질 수 있다.
- 설계시 많은 시간과 노력이 필요

### Java의 장단점

장점

- JVM 위에서 동작하기 때문에 운영체제에 독립적이다.
- 가비지컬렉터가 메모리를 관리해주기 때문에 편리하다.단점
- JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
- 다중 상속이나 타입에 엄격하는 등 제약이 있는 것이 많다.

### 클래스와 인스턴스는 무엇인지 설명해주세요.

### 클래스

어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것

### 객체(Object)

클래스를 기반으로 선언된 대상

### 인스턴스

클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

### 추상화가 뭔가요?

불필요한 정보는 숨기고 중요한 정보만 표현함으로써 공통의 속성이나 기능을 묶어서 이름을 붙이는 것

### 캡슐화가 뭔가요?

캡슐화는 기능과 특성의 모음을 클래스라는 캡슐에 분류해서 넣는 것이 캡슐화 이고 캡슐화의 장점은 기능과 특성을 모으고 분류하기 때문에 코드 수정이 용이하고 그에 따라 코드의 재활용이 쉽다.

### 상속?

상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용 할 수 있고 수정이 필요하면 자식 클래스에서 다시 정의하여 상용 할 수 있기에 코드 수정이 용이하다.

### 다형성?

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될수있는 점

### 오버라이딩

부모 클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것

### 오버로딩

같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출 할 수 있게 하는것

### getter, setter

맴버변수에 직접 접근하지 못하게하고 매서드를 통해서 접근하기 하기 위해서 사용합니다.

## 스프링(Spring is coming...)

스프링은 안전성, 성능, DI(의존성 주입) 등의 강력한 장점이 있다. 하지만 개발 환경 설정이 어렵다는 단점있는데 이를 보완하기 위해서 스프링 부트가 개발되었다. 스프링 부트는 환경 설정을 최소화하고 개발자가 비즈니스 로직에 집중할 수 있게하여 생산성을 크게 향상시켰다.

### 스프링 프레임워크 특징

- 경량 컨테이너로 자바 객체를 직접 관리한다.
- POJO(plain old java object) 방식의 프레임 워크이다.
    - 특정 기술에 종속되어 동작하는 것이 아닌 순수한 자바 객체, 특정 기술에 의존 하지 않는다.
- IoC
    - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
- DI
    - 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결한다.
- AOP(관점 지향 프로그래밍)
    - 트랜잭션, 로깅, 보안과 같은 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리가 가능하다

### 스프링 부트의 특징

스프링 프레임워크 기반 프로젝트의 어려운 설정이나 WAS에 대한 설정 없이 바로 개발이 가능 할 수 있게 해주는 프레임워크

### 라이브러리 관리 자동화(의존성 관리가 편함)

- 스프링에서는 maven, gradle에서 라이브러리 의존성을 관리해왔다면, 스프링 부트는 스프링 부트 스타터에서 특정 기능에 필요한 라이브러리 의존성을 간단하게 처리 할 수 있다.

### 라이브러리 버전 자동 관리(버전 관리가 편함)

- 스프링에서는 라이브러리의 버전을 하나하나 직접 관리했지만 스프링 부트에서는 스프링 라이브러리 뿐만 아니라 서드파티 라이브러리들도 호환되는 버전으로 관리해준다. 따라서 라이브러리 버전이 달라 발생하는 오류를 겪을 필요가 없다

### 설정의 자동화(환경 설정이 편함)

- 스프링 부트에서는 필요한 라이브러리를 추가해주면 알아서 실행에 필요한 환경을 자동으로 설정해준다. 개발자들이 직접 설정할 필요가 없다. @EnableAutoConfiguration 어노테이션을 사용

### 단독 실행이 가능하다(내장 서버 보유)

- 내장 서버인 톰캣을 가지고 있어서 단독 파일만으로 애플리케이션을 실행 할 수 있다. 이전에는 내장 서버가 없어서 직접 WAS 서버를 설치해줘야 했다. 이제는 내장 서버인 톰켓이 있어서 jar로 배포하여 단독 파일로 실행이 가능하다.

### 간단한 정리

- 번거로운 XML 설정 요구 X
- CoC: Convention over Configuration

  : 일일히 관련 라이브러리를 찾아 추가할 필요 없이 spring-boot-starter-web을 추가하면 관련 라이브러리를 받아온다.

- 내장 Tomcat, Jetty, Undertow

  : Tomcat, Jetty, Undertow와 같은 서버를 내장하고 있어 특별한 설정 없이 Web Starter의 의존성만 추가해주면 @SpringBootApplication 어노테이션이 선언되어 있는 클래스의 main() 메소드를 실행하는 것만으로 서버를 구동시킬 수 있다.

- 설정의 자동화

  : 어노테이션을 선언하여 스프링에서 자주 사용했던 설정들을 자동으로 등록한다.

초기에는 @EnableAutoConfiguration 어노테이션, 현재는 @EnableAutiConfiguration + @SpringBootConfiguration + @ComponentScan으로 구성되어 있는 @SpringApplication 어노테이션을 사용한다.

- 라이브러리 버전 자동 관리

  : pom.xml에 스프링 부트 버전을 입력하면 스프링 라이브러리뿐만 아니라 서드 파티 라이브러리들도 호환되는 버전으로 자동으로 다운된다.

- 단독으로 실행이 가능한 JAR

  : WAR 파일로 패키징 해야하는 웹 프로젝트와 달리, 내장 Tomcat을 지원하기 때문에 JAR파일로 패키징 하여 웹 애플리케이션 실행 가능하다.

### 싱글톤 패턴이란?

싱글톤 패턴은 단 하나의 인스턴스를 생성하여 사용하는 디자인 패턴이다. 싱글톤 패턴은 인스턴스를 한번만 생성하기 때문에 메모리의 낭비를 방지할 수 있습니다. 또한 싱글톤 패턴으로 생성된 인스턴스는 전역 변수이기 때문에 데이터를 공유하기 쉽습니다. 하지만 자바에서는 싱글톤 패턴을 안티 패턴으로 좋지 않은 디자인 패턴으로 생각하고 있습니다. 그 이유는 인스턴스간의 결합도가 높아서 객체 지향 설계 원칙에 어긋나기 때문입니다. 또한 멀티 쓰레드 환경에서 thread safe를 보장하지 않기 때문에 사용하기 어렵기 때문입니다.

하지만 Spring에서는 싱글톤 패턴을 지원해주고 있습니다. 스프링 컨테이너가 관리하는 Bean을 싱글톤 패턴으로 구현하여 자동으로 Thread safe를 보장해줍니다.

### MVC 패턴이란?

Model, View, Controller 이렇게 3개의 개념으로 구분 할 수 있다. 모델은 어떤한 동작을 수행하는 코드를 이야기한다. 우리가 무엇을 할지 정하고 비즈니스 로직과 db 등에 대한 처리를 수행한다. 컨트롤러는 뷰와 모델을 이어주는 역할을 맡는다. 뷰의 요청에 따라 모델의 상태를 바꾸고 이를 다시 뷰에 전달한다. 뷰는 사용자에게 보이는 영역이다.

이렇게 세 가지 요소로 나누어진 패턴을 MVC패턴이라고 하고 MVC1, MVC2로 또 나뉜다.

사용이유: 비지니스 로직과 프리젠테이션 로직을 분리하기 위해서 사용한다.

### MVC1

MVC1 패턴의 경우 View와 Controller 모두 JSP에서 담당하는 형태를 가진다. JSP 하나에서 유저의 요청을 받고 응답을 처리하는 형식임으로 구현 난이도는 쉽다. 하지만 규모가 거대해질수록 하나의 JSP에서 많은 일을 처리하다보니 재사용성과 가독성이 떨어집니다. 즉 유지보수가 문제가 발생합니다.

### MVC2

MVC2는 MVC 패턴의 표준으로 사용되는 패턴입니다. MVC1과는 다르게 Controller와 View가 분리되어 있습니다. 역할에 따라 분리되어 있기에 M,V,C중에서 수정해야 할 부분이 있으면 그것만 꺼내서 수정하면됩니다. 따라서 유지보수 측에서 큰 이점을 가지고 있습니다. 이러한 이유에서 스프링이 MVC2를 선택하였습니다.

### Spring(MVC2)에서 요청을 처리하는 로직

1. 클라이언트에서 요청이 들어오면 DispatcherServlet에서 받고 HandlerMapping에게 전달해줍니다.
2. HandlerMapping에서 요청에 매핑되는 컨트롤러를 검색하고 결과를 DispatcherServlet으로 반환합니다.
3. DispatcherServlet에서 다시 HandlerAdapter을 호출하여 HandlerMapping에게 받은 Controller 중 적합한 Method를 찾아서 반환해준다.
4. Controller의 해당하는 Method에서 비즈니스 로직을 처리하고 해당하는 결과를 View에 전달 하기 위해서 Model에 저장 후 view name을 DispatcherServlet에 전달합니다.
5. DispatcherServlet은 ViewResolver를 호출하여 view name을 검색하고 결과를 View에 전달한다. View에서 시각적 처리를 완료한 후에 다시 DispatcherServlet에 결과를 전달한다.
6. DispatcherServlet에서는 전달받은 View의 처리결과를 클라이언트에 전달한다.

### DispatcherServlet?

서블릿 컨테이너의 제일 앞에서 서버로 들어오는 모든 클라이언트 요청을 받아서 처리해주는 컨트롤러이다.

### what is Servlet

클라이언트의 요청에 따라 동적인 컨텐츠를 처리하기 위한 웹 어플리케이션 컴포넌트입니다.

### Spring 컨테이너

### BeanFactory

- Bean의 라이브사이클을 관리하는 컨테이너
- 컨테이너가 구동될 때 Bean 객체를 생성하는 것이 아니라 사용되는 시점에 객체를 생성하는 방식을 사용하고 있다.

### ApplicationContext

- BeanFactory를 상속 받고 확장된 향상된 컨테이너이다.
- AOP, IOC, DI 등의 처리를 해주고 메시지 기반의 다국어 처리
- BeanFactory와 다르게 컨테이너가 구동되는 시점에 Bean 객체들을 생성하는 방식을 취하고 있다.

### Bean의 라이프사이클

- 객체 생성 -> 의존설정 -> 초기화 -> 소멸
- 스프링 컨테이너가 초기화 할 때, 빈 객체를 설정 정보에 따라 생성하고, 의존 관계를 설정한다. 의존 설정이 완료되면, 빈 객체가 지정한 메소드를 호출해 초기화 한다. 컨테이너가 종료될 시 빈 객체가 지정한 메소드를 호출해 빈 객체의 소멸을 처리한다.

# JDBC란?

자바 언어로 다양한 RDB에 접근하여 SQL문을 수행하고 처리할 수 있게 도와주는 SQL 인터페이스 API이다.

java application 아래 JDBC API가 존재하고 그 아래 JDBC DriverManager이 존재하고 그 아래 각각의 JDBC Driver가 존재한다. Mysql 전용 JDBC Driver, Oracle 전용 JDBC Driver.... 등등

!https://velog.velcdn.com/images%2Fhyundong_kk%2Fpost%2F20d5ec7d-d8b2-4b25-8bf7-f160f370d5c5%2Fimage.png

1단계. 드라이버를 로드한다.

2단계. Connection 객체를 생성하여 DB에 접속한다.

3단계. Statement 객체를 생성 및 실행한다. (SQL문 실행)

4단계. 3단계에서 SQL문의 실행결과가 있으면 ResultSet 객체를 생성한다.

5단계. 모든 객체를 닫는다.

### JDBC 한계(java에서 데이터베이스 접근 가능하게 해줌)

JDBC API를 통해서 자바에서 직접 DB에 접속하여 데이터를 관리하는게 가능했었다. 하지만 반복되는 CRUD의 SQL문을 작성하는데 시간이 많이 소요되서 불편함이 많았다. Java는 객체지향적 프로그램인데 데이터베이스를 작성하는 코드를 보면 DBMS와 다를바가 없었다. 그래서 RDB의 데이터를 객체화 시켜 java 객체 처럼 사용하기 위해서 ORM과 SQL Mapper가 등장하였다.

### SQL Mapper

### (SQL문을 사용하여 DB에 접근하고 데이터를 객체화 시켜서 자바 객체에 넣어줌)

SQL문을 이용하여 RDB에 접근하고 데이터를 객체화 시켜준다. sql 쿼리를 그대로 사용하기 때문에 DB 튜닝이 수월하다. 또한 sql 쿼리의 세부적인 내용 변경 시 ORM보다 편하다. 하지만 SQL을 이용해서 데이터에 접근하기 때문에 RDB를 변경하기가 쉽지 않다. RDB마다 sql문법이 다르기 때문에 RDB를 바꾼다면 그에 맞는 sql문법을 다 수정해야 되기 때문이다.

### ORM

### (DB의 데이터 자체를 객체화 시키고 ORM이 중간에서 어떤 자바 객체에 매핑할지 결정함)

SQL문을 이용하여 RDB에 접근하는것이 아니라 자바 객체와 RDB의 데이터를 별개로 설계하고 그 중간에서 자바 객체와 RDB의 데이터 객체를 매핑해주는 역할을 한다. SQL문으로 접근하는 것이 아니기에 RDB를 변경하기 쉽다. RDB에 종속적이지 않다. SQL문을 알아서 작성해준다. 하지만 SQL문을 자동으로 작성해주기 때문에 SQL 성능 개선이 어렵다. 자동으로 설정해주기 때문에 데이터 간의 관계를 잘 설정해줘야 한다.

### JPA이란?(기술 명세서)

특정 언어를 sql문으로 변환해주는 ORM중 자바를 SQL문으로 변환 시켜주는게 JPA입니다. JPA를 사용함으로써 개발자가 sql 쿼리를 직접 작성하지 않아도 됩니다.

### Spring Data Jpa(JPA를 기반으로 만든 구현체)

Spring Data Jpa는 Spring에서 데이터베이스 관련 개발을 좀더 편하게 하기 위해서 제공하는 모듈입니다.

디폴트 설정으로 Hibernate가 설정이 되어있어 손쉽게 데이터베이스와 통신 할 수 있습니다.

### Hibernate

JPA를 구현해놓은 구현체입니다. 일반적으로 스프링 부트에서 Hibernate를 디폴트 JPA provider로 사용하고 있습니다. 어노테이션으로 쉽게 객체 생성 및 어노테이션을 통한 맵핑이 가능합니다. ex) @Entity, @Table, @Id, @Column...

### JPA 영속성 컨텍스트란?

영속성 컨텍스트란 데이터를 영구적으로 저장 할 수 있는 환경을 의마합니다.

### 영속성 컨텍스트의 특징

- Entitiy를 식별자 값으로 구분합니다.
- 1차 캐시를 이용합니다.
    - 1차 캐시: 영속성 컨텍스트 내부에 존재하는 캐시, entityManager.find()가 호출되면 먼저 영속성 컨텍스트를 찾고 없으면 데이터베이스를 조회합니다.
- 객체의 동일성을 보장합니다.
- 트랜잭션을 지원한느 쓰기 지연을 수행합니다.
    - EntityManager은 트랜잭션을 커밋하기 전까지 데이터베이스에 저장하지 않고 영속성 컨텍스트 내부에 저장합니다. 이후 커밋을 하게되면 저장해두었던 쿼리들을 데이터베이스에 보냅니다.
- 변경을 감지합니다.
    - 엔티티 수정 시 따로 쿼리를 조작할 필요가 없다. 영속성 컨텍스트에서 Entity 상태의 변화를 감지하면 변경된 부분을 처리하는 쿼리문을 작성한 후에 트랜잭션 커밋이 일어날 때 같이 데이터베이스로 보내집니다.
- 지연 로딩을 수행합니다.
    - 지연 로딩이란 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속 성 컨텍스트를 통해 데이터를 불러오는 방법입니다.

### EntityManagerFactory

생성하는데 비용이 크기 때문에 애플리케이션 전체에서 한 번만 생성해 공유하도록 설계되어있다. 여러 스레드가 동시에 접근해도 안전하다. 따라서 서로 다른 스레드 간에 공유가 가능하다.

### EntityManager

생성하는데 거의 비용이 들지 않는다.

여러 스레드가 동시에 접근하면 동시성 문제가 발생하기 때문에 스레드 간에 절대 공유하지 않는다.

### 흐름

요청이 들어오면 EntityManagerFactory에서 EntityManger를 생산한다. EntityManger에서 실질적인 CRUD가 일어난다.

### Entity의 생명주기

1. 비영속영속성 컨텍스트와 전혀 관계가 없는 상태객체를 생성함
2. 영속영속성 컨텍스트에 관리되는 상태생성한 객체를 영속성 컨텍스트에 저장함
3. 준영속영속성 컨텍스트에 저장되었다가 분리된 상태, 식별자 값이 영속성 컨텍스트에 남아있어서 되돌리기 가능객체를 영속성 컨텍스트에서 분리함
4. 삭제삭제 된 상태객체를 삭제

### Entity란?

실제 데이터베이스의 테이블과 1대1로 매핑되는 클래스로 DB의 테이블내에 존재하는 컬럼을 속성으로 갖고 있습니다. Entitiy 클래스는 실제 테이블과 매핑이 되어있기 때문에 변경이되면 다른 클래스에 영향을 끼치게됩니다. 따라서 Entity 클래스는 변경되거나 데이터드를 주고받는 행위는 지양 되어야 합니다.

### DAO와 DTO와 VO의 차이

### DAO란?

데이터 접근을 목적하는 객체이다. DB에 대한 inert, update, delete, select를 처리한다.

### DTO란? for. 데이터 교환

DTO는 계층간 데이터를 교환을 위해 사용하는 객체입니다. 데이터 교환이 주된 목적으로 사용하므로 로직을 갖지 않습니다.

### VO란? for. 데이터 저장

DTO와 비슷한 개념입니다. 하지만 DTO와 다른점은 DTO는 setter을 사용하여 값을 변화 시킬수있는 가변적 성격을 지닌 클래스라면 VO는 setter을 사용하지 못하고 getter을 사용하여 값을 가져오기만 할 수있는 불변적 성격을 지닌 클래스라는 차이점이 있습니다.(read only)

## 데이터베이스

### 인덱스란?

인덱스는 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 추가적인 쓰기 작업과 저장 공간이 필요하지만 검색속도를 향상시키기 때문에 사용한다.

### 인덱스의 자료구조

- 해시 테이블
- B+Tree: BTree의 노드들을 연결리스트로 연결하여 순차검색을 용이하게 하였다.

### DB 정규화

- 제 1 정규형 : 모든 속성 값이 원자 값을 갖도록 분해한다.
- 제 2 정구형 : 제 1 정규형을 만족하고, 부분함수 종속을 제거한다.
- 제 3 정구형 : 제 2 정규형을 만족하고, 이행함수 종속을 제거한다.

https://nirsa.tistory.com/107

### 트랜잭션

하나 이상의 쿼리를 처리할 때 동일한 객체를 공유하여 에러가 발생하면 모든 과정을 되돌리기 위한 방법입니다.

## 운영체제

### 메모리란?

메모리는 컴퓨터에서 작업을 수행하기 위해 처리 대상이나 결과 등을 저장하기 위한 공간입니다.

### 프로그램? 프로세스? 쓰레드?

프로그램은 컴퓨터 안에 저장되어 있는 정적인 코드 덩어리이다.

프로세스는 정적인 코드 덩어리가 메모리에 올라가서 동적인 활동을하고 있는 프로그램의 인스턴스이다.

쓰레드는 프로세스에서 자원을 할당받아 동작을 실행하는 단위이다.

### 프로세스와 쓰레드의 특징

프로세스는 운영체제로부터 독립적인 메모리를 할당 받는다. 따라서 다른 프로세스 끼리 자원을 공유 할 수 없다. 쓰레드는 이런 프로세스로 부터 자원을 할당을 받기 때문에 같은 프로세스 안의 쓰레드 끼리는 자원을 공유 할 수 있습니다. 쓰레드는 code, data, stack, heap 영역을 가지고 있는데 쓰레드 끼리 stack을 제외하고 code, data, heap을 공공제로써 공유한다. 쓰레드는 프로세스 안의 자원을 공유하고 있기 때문에 쓰레드에서 오류가 발생하면 프로세스 전체가 멈춘다.

### Context switching

프로그램은 운영체제로 부터 자원을 할당받아서 동작을 하는데 사용자가 보기에는 동시에 작동하는 것 처럼 보입니다. 그 이유는 매우 빠른속도로 운영체제가 실행중인 프로세스에게 자원을 할당하고 중지하고 할당하고 중지하고를 반복하기 때문입니다. 현재 자원을 할당받은 프로세스에서 다른 프로세스로 자원이 이동하는 처리과정을 컨텍스트 스위칭이라고 합니다.

### 멀티 프로세스와 멀티 쓰레드

### 멀티 프로세스 VS 멀티 쓰레드

한개의 프로그램을 여러 개의 프로세스로 구성하여 처리하는 것이 멀티 프로세스이고 한개의 프로그램을 여러개의 쓰레드로 구성하여 처리하는 것이 멀티 쓰레드이다.

멀티 프로세스는 1개의 프로세스가 죽어도 다른 프로세스들을 계속 실행된다는 장점이 있고, context switching을 위한 오버헤드가 발생하고, 각각의 독립적인 메모리를 할당받았기 때문에 통신하는 것이 어렵다는 단점을 가지고 있다.

반면, 멀티 쓰레드는 자원을 공유하기 때문에 context switching의 오버헤드를 줄일 수 있고 자원을 공유하기 때문에 통신이 쉽고 자원을 공유하는 만큼 자원을 절약 할 수 있다. 하지만 하나의 쓰레드에서 문제가 발생하면 전체 프로세스가 영향을 받고, 하나의 쓰레드에서 하나의 자원에 동시에 접근하는 동시성 문제가 발생 할 수 있다는 단점이 있다.

### 멀티 쓰레드의 동시성 문제를 해결하기 위한 방법

동시화 기법을 사용하여 동시성 문제를 해결한다.

## 네트워크

### Web Server와 Web Application Server의 차이

- web Server는 정적인 컨텐츠를 제공해주는 소프트웨어 이고 WAS는 동적인 컨텐츠를 주로 제공해주는 소프트웨어입니다. WAS에서 동적인 컨텐츠 뿐만 아니라 정적인 컨텐츠까지 제공이 가능하지만 둘을 분리하여 사용하는 이유는 자원의 효율적인 사용과 문제 해결 및 유지 보수의 편리성 때문입니다.
- 클라이언트로 부터 정적인 요청을 받으면 ws에서 처리를하고 ws에서 처리하지 못한 것들은 was로 넘겨서 처리해준다.
- 일반적으로 was 앞에 ws를 두고 사용한다. 그 이유는 ws의 보안 측면에서 사용한다. 뿐만 아니라 트래픽을 분산 시켜주는 로드밸런싱 때문에 ws를 앞에 둔다.
- ws를 사용하는 보안상의 이유

웹 서버는 프록시라는 기능을 제공해준다. 프록시란 대신 전달해주는 역할을 하는데 일반적으로 클라이언트가 직접 서버에 데이터를 요청하지 않고 프록시에게 요청을하면 프록시가 클라이언트의 요청을 대신해서 서버에 전달해준다. 이렇게 대신 해줌을 통해서 서버는 클라이언트의 주소를 알지 못한다. 왜나면 프록시가 대신 전달해주었기 때문이다. 이렇게 클라이언트의 정보를 감춰주는 기능을 forward proxy라고 한다. forward proxy는 클라이언트의 주소만 감춰주는 것이 아니라 클라이언트가 서버에 자주 요청하는 데이터들을 캐싱해 두어서 캐싱 데이터가 있다면 서버까지 가지 않고 forward proxy에서 처리해서 바로 전달 할 수 있다. 이는 응답처리 속도가 빠르고, 서버에 부담을 줄여주는 장점이 있다.

반대로 클라이언트로부터 서버의 내부구조를 숨길 때 사용하는 것이 reverse proxy라고 합니다. 또한 reverse proxy 또한 캐싱 기능을 제공하여 클라이언트가 자주 요청하는 데이터들을 서버단에서 캐싱해서 가지고 있다가 요청이 들어오면 바로 전달해주는 역할을 한다. 위의 forward proxy의 캐싱은 클라이언트 단의 캐싱이라고 생각하면, reverse proxy의 캐싱은 서버단의 캐싱이라고 생각하면 된다.

- ws를 사용하는 트래픽 분산의 이유

웹 서버는 많은 트래픽이 몰릴 때 로드밸런싱을 통해서 트래픽을 분산시켜준다. 하나의 웹 서버안에 여러개의 was 서버를 연결하여 요청이 들어오면 하나의 was에만 요청이 들어가는 것을 방지하고 분산시켜주는 역할을 합니다. 또한 여러개의 was를 두는 것은 무중단 배포를 하기 위함도 있다. 업데이트가 발생하면 was를 차례대로 업데이트를 진행하고 업데이트가 진행되지 않는 was에서는 평소처럼 서비스를 제공하는 식으로 무중단 배포를 수행 할 수 있다.

### was의 대표는 Tomcat

### ws의 대표는 아파치, Nginx

### 아파치 vs Nginx

아파치는 오래된 ws 프로젝트로 오랫동안 웹 서버에서 사용되어 왔다. Nginx는 비교적 최근에 나온 기술로 가벼움을 강점으로 하고 있다. 최근에 Nginx로 점유율을 뺏기고 있다. 하지만 무조건적으로 Nginx가 좋은 것은 아니고 상황에 따라 적합한 웹서버를 사용하야된다.

일단 이 둘의 차이점은 일을 처리하는 방식에 있다. 아파치는 MPM(멀티 프로세스 + 쓰레드 모듈)방식으로 일을 처리하고 Nginx는 event driven 방식으로 일을 처리한다.

아파치에서는 요청이 들어올 때 마다 프로세스 혹은 쓰레드를 새로 생성해서 일을 처리하는데 이는 요청이 많을수록 컴퓨터에 부담이 크다. 또한 컨텍스트 스위칭이 발생하여 자원을 많이 소모한다.

Nginx에서는 싱글 프로세스, 쓰레드에서 요청이 발생하는 것을 감지하여 처리하는 방식을 취하고 있다. 하나의 쓰레드, 프로세스에서 요청을 수행하다보니 컨텍스트 스위칭으로 인한 오버헤드가 발생하지 않아 빠른 처리가 가능하다. 또한 비동기 처리로 적은 메모리로 운영이 가능하다.

각각의 장단점이 있기 때문에 성능과 가벼움을 중요시하는 서비스에서는 Nginx를 사용하고, 다양하고 검증된 기능을 필요로하는 곳에서는 오래되서 안전한 아파치를 사용한다.

### 프로토콜?

프로토콜은 컴퓨터 간의 메시지를 주고 받기 위한 약속

### TCP/IP 프로토콜

인터넷 동작의 중심이 되는 통신규약으로 데이터의 흐름 관리, 데이터의 정확성 확인, 패킷을 목적지까지 전송하는 역할을 담당합니다.

### TCP vs UDP

TCP는 연결지향형 프로토콜로 3 way handshake 방식을 취하고 있습니다. 보낸 데이터를 확인하는 절차를 거치기 때문에 데이터의 신뢰성이 높습니다. 하지만 데이터의 신뢰성을 보장을 확인하는 작업을 추가적으로 하기 때문에 속도가 상대적으로 느립니다. 반면에 UDP는 비연결지향형 프로토콜입니다. 데이터가 잘 수신됬는지 확인을 하지 않기 때문에 신뢰성이 낮습니다. 하지만 그 만큼 속도가 빠릅니다.

일반적으로 TCP는 신뢰성이 필요한 EMAIL 전송 등의 작업에서 사용되고 UDP는 스트리밍 서비스에서 사용됩니다.

### SOCKET

server와 클라이언트가 특정 포트를 통해서 실시간으로 양방향 통신을 하는 방식

### SOCKET 특징

- Server와 Client가 계속 연결을 유지하는 양방향 통신이다.
- 실시간으로 데이터를 주고 받는 상황에서 사용된다.
- 실시간 동영상 스트리밍에서 사용된다.

### HTTP

HyperText Transfer Protocol의 약자로 하이퍼텍스트 문서를 교환하기 위해 사용된 통신 규약입니다.

### HTTP 특징

- TCP/IP를 이용하는 응용 프로토콜 입니다.
- HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜입니다.
- request/response 방식으로 동작합니다.

### HTTP의 GET vs Post

- GET
    - 요청하는 데이터가 url안에 value와 key가 결합된 쿼리 스트링 형태로 HTTP Request Message의 Header에 담겨서 전송된다.
    - 전송할 수 있는 데이터가 한정적이다.
    - url에 전송하려는 데이터가 노출되어있다.
- POST
    - 요청하는 데이터가 HTTP Request Message의 Body에 담겨 전송된다.
    - 대량의 데이터를 전송할 수 있다.
    - 전송하는 데이터가 노출되어 있지 않아 GET보다 보안성이 높다.

### TCP 3-way HandShake

클라이언트와 서버가 정확한 통신을 하기위하여 사용되는 방법이다.

- 1단계: 클라이언트는 서버에게 접속을 요청한다.
- 2단계: 서버는 요청에 대한 응답값을 클라이언트에 전달하고 클라이언트의 응답을 기다린다.
- 3단계: 클라이언트는 서버가 수락을 했으면 서버에 접속하고 데이터가 오간다.

### HTTP 와 HTTPS

HTTP는 서로 다른 시스템들 사이에서 데이터를 주고 받기 위한 프로토콜이다. 하지만 HTTP는 전송되는 데이터 정보가 암호화 되지 않았다. 이를 암호화 시키기 위해서 등장한 것이 HTTPS이다.

### SSL

HTTPS는 SSL 인증서를 사용하여 암호화를 수행한다. SSL인증은 암호키를 사용하여 HTTP안에 정보를 암호화 한다. 해당 암호키는 비대칭키를 사용한다. 공개키를 사용하여 암호화를 하고 개인키를 사용하여 복호화를 진행한다. 반대로 개인키로 암호화하고 공개키로 복호화가 가능하다. 일반적으로 공개키 암호화는 클라이언트가, 개인키 복호화는 서버가 수행합니다..

https://velog.io/@hyundong_kk/SSLSecure-Sockets-Layer

### 웹 동작 방식

1. 사용자가 브라우저에 url을 입력한다.
2. 브라우저는 DNS를 통해서 진짜 서버의 주소를 찾는다.
3. HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성한다.
4. TCP/IP 연결을 통해 HTTP 요청이 서버로 전송된다.
5. 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메시지를 생성한다.
6. TCP/IP 연결을 통해 요청한 컴퓨터로 전송한다.
7. 도착한 HTTP 응답 메시지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.

## 자료구조

### List , Map, Set

list 컬렉션은 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동적으로 인덱스를 부여한다. 인덱스로 객체를 검색 및 삭제 할 수있다. 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.

Set 컬렉션은 집합을 정의하며 요소의 중복을 허용하지 않고 순서가 상관이 없습니다.

Map 컬렉션은 key와 value의 쌍으로 연관지어 저장하는 자료구조입니다. 키는 중복으로 저장 할 수 없고 값은 중복으로 저장 할 수 있으며 중복으로 저장되면 기존의 값은 없어지고 새로운 값으로 대치됩니다.

### String, StringBuffer, StringBuilder

String은 불변성을 가진 클래스입니다. 반면에 나머지 두개는 가변성을 가집니다. String에서 객체를 수정하면 기존의 객체에서 새로운 값을 합하는 것이 아니라 완전히 새로운 객체를 생성하게됩니다. 반면에 StringBuffer나 StringBulider는 기본의 객체를 수정하게되면 새로운 객체가 생성되는 것이 아니라 기존의 객체를 수정하여 사용합니다.

StringBuffer와 StringBulider의 차이는 동기화의 유무입니다. StringBuffer는 동기화 키워드를 지원합니다. 따라서 멀티쓰레드 환경에서 안전합니다. 반면에 StringBulider는 동기화를 지원하지 않아서 멀티 쓰레드 환경에서 사용하기 적합하지 않습니다. 하지만 동기화를 신경쓰지 않는 만큼 싱글 쓰레드에서는 StringBuffer보다 성능이 좋습니다.

출처: [https://velog.io/@hyundong_kk/기초-cs-정리](https://velog.io/@hyundong_kk/%EA%B8%B0%EC%B4%88-cs-%EC%A0%95%EB%A6%AC)